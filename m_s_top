module spi_mt #(parameter a_width=8,d_width=16)(clk,rst,start,r_w,w_addr,w_data,r_addr,r_data,sclk,cs,sdio);
    input clk,rst,start,r_w;
    input [a_width-1:0]w_addr,r_addr;
    input [d_width-1:0]w_data;
    output reg [d_width-1:0]r_data;
    output reg sclk,cs;
    inout sdio;
   
    reg [a_width-1:0]a_shift;
    reg [d_width-1:0]d_shift;
    reg [a_width-1:0]count;
   
    reg [2:0]state;
   
    localparam idle=0,
               inst_rw=1,
               wr_addr=2,
               wr_data=3,
               rd_data=4;
               
    reg drive,sdo;
    wire sdi;
   
    assign sdio=drive?sdo:1'bz;
    assign sdi=sdio;
   
    always @(posedge clk or posedge rst) begin
        if(rst) begin
            count<=0;
            a_shift<=0;
            d_shift<=0;
            sclk<=0;
            cs<=1;
            drive<=0;
            sdo<=0;
            r_data<=0;
            state<=idle;                        
        end
        else begin
            case (state)
                idle:begin
                    sclk<=0;
                    cs<=1;
                    drive<=0;
                    count<=0;
                   
                    if(start) begin
                        cs<=0;
                        drive<=1;
                        count<=0;
                        a_shift<=r_w?r_addr:w_addr;
                        state<=inst_rw;
                    end
                end
               
                inst_rw:begin
                    sclk<=~sclk;
                    if(sclk==0)begin
                        sdo<=!r_w;
                        count<=a_width;
                        state<=wr_addr;
                    end
                end
               
                wr_addr: begin
                    sclk<=~sclk;
                        if(sclk==0) begin
                            sdo<=a_shift[a_width-1];
                            a_shift<={a_shift[a_width-2:0],1'b0};
                            count<=count-1;
                        if(count==1)begin
                            if(r_w) begin
                                drive<=0;
                                count<=d_width;
                                state<=rd_data;
                            end
                            else begin
                                drive<=1;
                                d_shift<=w_data;
                                count<=d_width;
                                state<=wr_data;
                            end
                        end
                    end    
                end
               
                wr_data: begin
                    sclk<=~sclk;
                    if(sclk==0) begin
                        sdo<=d_shift[d_width-1];
                        d_shift<={d_shift[d_width-2:0],1'b0};
                        count<=count-1;                        
                        if(count==0)begin
                            count<=0;
//                            cs<=1;
//                            sclk<=0;
                            drive<=0;
                            state<=idle;
                        end
                    end
                end
               
                rd_data:begin
                    sclk<=~sclk;
                    if(sclk==1)begin
                        d_shift<={d_shift[d_width-2:0],sdi};
                        count<=count-1;
                           
                        if(count==1)begin
                            r_data<={d_shift[d_width-2:0],sdi};
                            count<=0;
//                            cs<=1;
//                            sclk<=0;
                            drive<=0;
                            state<=idle;
                        end
                    end
                end
                default:state<=idle;
            endcase
        end  
    end
endmodule


module spi_s #(parameter d_width=16, a_width=8)(rst,sclk,cs,sdio);
    input rst,sclk,cs;
    inout sdio;
   
    reg [d_width-1:0]mem[a_width:0];
    reg [a_width-1:0]reg_addr;
   
    reg [a_width-1:0]count;
    reg [a_width-1:0]a_shift;
    reg [d_width-1:0]d_shift;
   
    reg [2:0] state;
   
    localparam idle=0,
               inst_rw=1,
               wr_addr=2,
               wr_data=3,
               rd_data=4;
                                 
    reg r_w,drive,sdo;
    wire sdi;
   
    assign sdio = drive ?sdo:1'bz;
    assign sdi=sdio;
   
    always @(posedge sclk or posedge rst or posedge cs)begin
        if(rst || cs)begin
            count<=0;
            r_w<=0;
            drive<=0;
            sdo<=0;
            a_shift<=0;
            d_shift<=0;
            reg_addr<=0;
            state<=idle;      
        end
        else begin
            if(cs)begin
                state<=idle;
                drive<=0;
                count<=0;
            end
            else begin
                case (state)
                    idle: begin
                        count<=0;
                        drive<=0;
                        state<=inst_rw;
                    end
                   
                    inst_rw:begin
                        if(count==0)begin
                        r_w<=sdi;
                        drive<=0;
                        count<=a_width;
                        state<=wr_addr;
                        end
                    end
                   
                    wr_addr: begin
                        a_shift<={a_shift[a_width-1:0],sdi};
                        count<=count-1;
                                         
                        if(count==1)begin
                            reg_addr<={a_shift[a_width-2:0],sdi};
                           
                            if(r_w!=0)begin
                                d_shift<=mem[{a_shift[a_width-2:0],sdi}];
                                count<=d_width;
                                drive<=1;
                                state<=rd_data;
                            end
                            else begin
                                drive<=0;
                                count<=d_width;
                                state<=wr_data;
                            end
                        end
                    end
                   
                    wr_data:begin
                        d_shift<={d_shift[d_width-2:0],sdi};
                        count<=count-1;
                       
                        if(count==1)begin
                            mem[reg_addr]<={d_shift[d_width-2:0],sdi};
                            count<=0;
                            state<=idle;
                        end
                    end
                   
                    rd_data: begin
                        sdo<=d_shift[d_width-1];
                        d_shift<={d_shift[d_width-2:0],1'b0};
                        count<=count-1;
                       
                        if(count==1)begin
                            count<=0;
                            drive<=0;
                            state<=idle;
                        end
                    end
                    default:state<=idle;
                endcase
            end
        end
    end
   
endmodule

module spi_t #(parameter a_width=8,d_width=16) (clk,rst,start,r_w,w_addr,w_data,r_addr,r_data,sclk_w,cs_w,sdio_w);
    input clk,rst,start,r_w;
    input [a_width-1:0]w_addr,r_addr;
    input [d_width-1:0]w_data;
    output sclk_w,cs_w;
    inout sdio_w;
    output [d_width-1:0]r_data;
       
    spi_mt s1(.clk(clk),.rst(rst),.start(start),.r_w(r_w),.w_addr(w_addr),.w_data(w_data),.r_addr(r_addr),.r_data(r_data),.sclk(sclk_w),.cs(cs_w),.sdio(sdio_w));
    spi_s s2(.rst(rst),.sclk(sclk_w),.cs(cs_w),.sdio(sdio_w));
   

endmodule
