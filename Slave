module spi_s #(parameter d_width=16, a_width=8)(rst,sclk,cs,sdio);
    input rst,sclk,cs;
    inout sdio;
    
    reg [d_width-1:0]mem[(1<<a_width)-1:0];
    reg [a_width-1:0]reg_addr;
    
    reg [a_width-1:0]count;
    reg [a_width-1:0]a_shift;
    reg [d_width-1:0]d_shift;
    
    reg [2:0] state;
    
    localparam idle=0,
               inst_rw=1,
               wr_addr=2,
               wr_data=3,
               rd_data=4;
                                  
    reg r_w,drive,sdo;
    wire sdi;
    
    assign sdio = drive ?sdo:1'bz;
    assign sdi=sdio;
    
    integer i;
    
    always @(posedge sclk or posedge rst) begin
        if (rst) begin
            for (i=0; i<256; i=i+1)
                mem[i] <= 0;
        end
    end

    always @(posedge sclk or posedge rst or posedge cs)begin
        if(rst | cs)begin
            r_w<=0;
        end
        else if(state<=inst_rw && count==0)begin
            r_w<=sdi;
            count<=count+1;
            state<=wr_addr;
        end
    end
    
    always @(negedge sclk or posedge rst or posedge cs)begin
        if(rst | cs)begin
            count<=0;
            drive<=0;
            sdo<=0;
            a_shift<=0;
            d_shift<=0;
            reg_addr<=0;
            state<=idle;       
        end
        
            else begin
                case (state)
                    idle: begin
                        count<=0;
                        drive<=0;
                        state<=inst_rw;
                    end
                    
                    wr_addr: begin
                        if(count>=1 && count<=a_width)begin
                            a_shift<={a_shift[a_width-2:0],sdi};
                            count<=count+1;
                        end                      
                        else begin
                            if(count==a_width+1)begin
                                reg_addr<={a_shift[a_width-2:0],sdi};
                                count<=0;
                                if(!r_w)begin
                                    d_shift<=mem[{a_shift[a_width-2:0],sdi}];
                                    drive<=1;
                                    state<=rd_data;
                                end
                                else begin
                                    drive<=0;
                                    state<=wr_data;
                                end
                            end
                        end
                    end
                    
                    wr_data:begin
                        if(count>=0 && count<d_width)begin
                            d_shift<={d_shift[d_width-2:0],sdi};
                            count<=count+1;
                            if(count==d_width)begin
                                mem[reg_addr]<=d_shift;
                                count<=0;
                                state<=idle;
                            end
                        end
                    end
                    
                    rd_data: begin
                        if (count>=0 && count<=d_width)begin
                            sdo<=d_shift[d_width-1];
                            d_shift<={d_shift[d_width-2:0],1'b0};
                            count<=count+1;
                        end    
                        if(count==d_width)begin
                            count<=0;
                            drive<=0;
                            state<=idle;
                        end
                    end
                    default:state<=idle;
                endcase
            end
    end
endmodule
